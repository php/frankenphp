# Производительность

По умолчанию FrankenPHP стремится обеспечить хороший компромисс между производительностью и простотой использования.
Однако можно существенно улучшить производительность, используя соответствующую конфигурацию.

## Количество потоков и воркеров

По умолчанию FrankenPHP запускает в 2 раза больше потоков и воркеров (в режиме воркера), чем доступное количество процессорных ядер.

Подходящие значения сильно зависят от того, как написано ваше приложение, что оно делает, и вашего аппаратного обеспечения.
Мы настоятельно рекомендуем изменить эти значения. Для наилучшей стабильности системы рекомендуется, чтобы `num_threads` x `memory_limit` < `available_memory`.

Чтобы найти подходящие значения, лучше всего провести нагрузочные тесты, имитирующие реальный трафик.
[k6](https://k6.io) и [Gatling](https://gatling.io) являются хорошими инструментами для этого.

Чтобы настроить количество потоков, используйте опцию `num_threads` директив `php_server` и `php`.
Для изменения количества воркеров используйте опцию `num` в секции `worker` директивы `frankenphp`.

### `max_threads`

Хотя всегда лучше точно знать, каким будет ваш трафик, реальные приложения, как правило, более непредсказуемы. [Конфигурация](config.md#caddyfile-config) `max_threads` позволяет FrankenPHP автоматически запускать дополнительные потоки во время выполнения до указанного предела.
`max_threads` может помочь вам определить, сколько потоков требуется для обработки вашего трафика, и сделать сервер более устойчивым к скачкам задержки.
Если установлено значение `auto`, лимит будет оценен на основе `memory_limit` в вашем `php.ini`. Если это невозможно,
`auto` вместо этого будет по умолчанию равно 2x `num_threads`. Имейте в виду, что `auto` может сильно недооценивать количество необходимых потоков.
`max_threads` аналогичен [pm.max_children](https://www.php.net/manual/en/install.fpm.configuration.php#pm.max-children) в PHP FPM. Основное отличие состоит в том, что FrankenPHP использует потоки вместо
процессов и автоматически делегирует их различным скриптам воркеров и 'классическому режиму' по мере необходимости.

## Режим воркера

Включение [режима воркера](worker.md) значительно улучшает производительность,
но ваше приложение должно быть адаптировано для совместимости с этим режимом:
необходимо создать воркер-скрипт и убедиться, что приложение не имеет утечек памяти.

## Не используйте musl

Alpine Linux-вариант официальных Docker-образов и бинарники по умолчанию, которые мы предоставляем, используют [библиотеку musl libc](https://musl.libc.org).

Известно, что PHP [медленнее работает](https://gitlab.alpinelinux.org/alpine/aports/-/issues/14381) при использовании этой альтернативной библиотеки C вместо традиционной библиотеки GNU,
особенно при компиляции в режиме ZTS (потокобезопасный), который требуется для FrankenPHP. Разница может быть существенной в среде с большим количеством потоков.

Также [некоторые ошибки проявляются только при использовании musl](https://github.com/php/php-src/issues?q=sort%3Aupdated-desc+is%3Aissue+is%3Aopen+label%3ABug+musl).

В производственных средах мы рекомендуем использовать FrankenPHP, слинкованный с glibc и скомпилированный с соответствующим уровнем оптимизации.

Этого можно достичь, используя Docker-образы на базе Debian, наши пакеты [.deb](https://debs.henderkes.com) или [.rpm](https://rpms.henderkes.com), или [компилируя FrankenPHP из исходников](compile.md).

## Настройка среды выполнения Go

FrankenPHP написан на языке Go.

В целом, среда выполнения Go не требует какой-либо специальной конфигурации, но в определенных обстоятельствах специфическая конфигурация улучшает производительность.

Вы, вероятно, захотите установить переменную окружения `GODEBUG` в значение `cgocheck=0` (по умолчанию в Docker-образах FrankenPHP).

Если вы запускаете FrankenPHP в контейнерах (Docker, Kubernetes, LXC...) и ограничиваете память, доступную для контейнеров,
установите переменную окружения `GOMEMLIMIT` в значение доступного объёма памяти.

Для более детальной информации, [страница документации Go, посвященная этой теме](https://pkg.go.dev/runtime#hdr-Environment_Variables), обязательна для прочтения, чтобы максимально использовать возможности среды выполнения.

## `file_server`

По умолчанию директива `php_server` автоматически настраивает файловый сервер для обслуживания статических файлов (ресурсов), хранящихся в корневой директории.

Эта функция удобна, но имеет издержки. Чтобы отключить её, используйте следующую конфигурацию:

```caddyfile
php_server {
    file_server off
}
```

## `try_files`

Помимо статических файлов и PHP-файлов, `php_server` также попытается обслуживать индексные файлы вашего приложения
и файлы индексов директорий (`/path/` -> `/path/index.php`). Если вам не нужны индексные файлы директорий,
вы можете отключить их, явно определив `try_files` следующим образом:

```caddyfile
php_server {
    try_files {path} index.php
    root /root/to/your/app # явное добавление root здесь позволяет улучшить кэширование
}
```

Это может значительно сократить количество ненужных файловых операций.

Альтернативный подход с 0 ненужных операций файловой системы заключается в использовании директивы `php` и разделении
файлов от PHP по пути. Этот подход хорошо работает, если всё ваше приложение обслуживается одним входным файлом.
Пример [конфигурации](config.md#caddyfile-config), которая обслуживает статические файлы из папки `/assets`, может выглядеть так:

```caddyfile
route {
    @assets {
        path /assets/*
    }

    # всё, что находится за /assets, обрабатывается файловым сервером
    file_server @assets {
        root /root/to/your/app
    }

    # всё, что не находится в /assets, обрабатывается вашим индексным или воркерным PHP-файлом
    rewrite index.php
    php {
        root /root/to/your/app # явное добавление root здесь позволяет улучшить кэширование
    }
}
```

## Плейсхолдеры

Вы можете использовать [плейсхолдеры](https://caddyserver.com/docs/conventions#placeholders) в директивах `root` и `env`.
Однако это предотвращает кэширование значений и существенно снижает производительность.

По возможности избегайте использования плейсхолдеров в этих директивах.

## `resolve_root_symlink`

По умолчанию, если корневая директория документа является символьной ссылкой, она автоматически разрешается FrankenPHP (это необходимо для правильной работы PHP).
Если корневая директория документа не является символьной ссылкой, вы можете отключить эту функцию.

```caddyfile
php_server {
    resolve_root_symlink false
}
```

Это улучшит производительность, если директива `root` содержит [плейсхолдеры](https://caddyserver.com/docs/conventions#placeholders).
В остальных случаях прирост будет незначительным.

## Логи

Логирование, безусловно, очень полезно, но, по определению,
оно требует операций ввода-вывода и выделения памяти, что значительно снижает производительность.
Убедитесь, что вы [правильно настроили уровень логирования](https://caddyserver.com/docs/caddyfile/options#log)
и логируете только то, что необходимо.

## Производительность PHP

FrankenPHP использует официальный интерпретатор PHP.
Все обычные оптимизации производительности, связанные с PHP, применимы к FrankenPHP.

В частности:

- убедитесь, что [OPcache](https://www.php.net/manual/en/book.opcache.php) установлен, включён и настроен должным образом;
- включите [оптимизацию автозагрузки Composer](https://getcomposer.org/doc/articles/autoloader-optimization.md);
- убедитесь, что кэш `realpath` достаточно велик для нужд вашего приложения;
- используйте [предварительную загрузку](https://www.php.net/manual/en/opcache.preloading.php).

Для более подробной информации прочтите [посвященную этому запись в документации Symfony](https://symfony.com/doc/current/performance.html)
(большинство советов полезны, даже если вы не используете Symfony).

## Разделение пула потоков

Приложения часто взаимодействуют с медленными внешними сервисами, такими как
API, который становится ненадежным при высокой нагрузке или постоянно отвечает более 10 секунд.
В таких случаях может быть полезно разделить пул потоков, чтобы иметь выделенные "медленные" пулы.
Это предотвращает потребление всех ресурсов/потоков сервера медленными конечными точками и
ограничивает параллелизм запросов, направленных к медленной конечной точке, подобно
пулу соединений.

```caddyfile
{
    frankenphp {
        max_threads 100 # максимум 100 потоков, разделяемых всеми воркерами
    }
}

example.com {
    php_server {
        root /app/public # корень вашего приложения
        worker index.php {
            match /slow-endpoint/* # все запросы с путём /slow-endpoint/* обрабатываются этим пулом потоков
            num 10 # минимум 10 потоков для запросов, соответствующих /slow-endpoint/*
        }
        worker index.php {
            match * # все остальные запросы обрабатываются отдельно
            num 20 # минимум 20 потоков для других запросов, даже если медленные конечные точки начнут зависать
        }
    }
}
```

В целом, также рекомендуется обрабатывать очень медленные конечные точки асинхронно, используя соответствующие механизмы, такие как очереди сообщений.
